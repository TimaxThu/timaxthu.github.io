---
layout: article
title: UML笔记
key: 20220406
tags: 计算机
pageview: false
modify_date: 2022-04-06
aside:
  toc: true
---

软件学院大二下UML课程笔记

<!--more-->

UML的结构包括**构造块building blocks、公共机制和构架**三个部分。

*UML有三种基本的构造块，分别是事物（thing）、关系（relationship）和图（diagram）。事物是UML的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合。规则是构造块如何放在一起的规定，包括为构造块命名；给一个名字以特定含义的语境，即范围；怎样使用或看见名字，即可见性；事物如何正确、一致地相互联系，即完整性；运行或模拟动态模型的含义是什么，即执行。*











**公共机制**是指达到特定目标的公共UML方法，主要包括规格说明（详细说明）、修饰、公共分类（通用划分）和扩展机制4种。
<font color = red>**公共机制**</font>指人们在使用UML时共同遵守的四种机制，使得使用UML变得比较简单。这四种公共机制是Specification(规格说明)、Adornment（修饰）、Common Divisions(公共划分)和Extensibility Mechanisms（扩展机制）。



规格说明是事物语义的细节描述，它是模型真正的核心。







【类图中的关系】

类图是系统的一种静态视图，用**聚合关系**可明确表示两类事物之间存在的**整体/部分形式的关联关系**。（**组合关系是特殊的聚合关系，这两者都是特殊的关联association关系**）。UML类图中,若类A中包含了其他类的实例,且当类A的实例消失时,其包含的其它类的实例也消失,则类A和它所包含的类之间存在**组合关系**。



已知类A和类B之间存在关联关系，类A可见类B，且**多重性**定义为1。则表示在编写代码时，类A存在一个属性，该属性的类型是类B。





聚合aggregation

组合composition

依赖dependency

泛化generalization







【用例Use Case视图】显示外部参与者观察到的系统功能

【用例use case】是一种有效捕获系统功能性需求的方法，它从参与者（Actor）角度刻画了参与者期望系统为其提供的功能或服务。

**用例的规格说明specification**：是对用例的详细说明，其中包含的内容包括：用例的主要参与者、次要参与者（如果有的话）；前置条件，即用例开始启动时系统需要满足的条件；**事件流**，这是用例规格说明中最重要的部分，其中包含了用例执行过程中参与者和系统之间交互的动作步骤；后置条件，即用例执行完成系统必须满足的条件。

【场景scenario】描述了用户与系统的一次特定的交互过程，相当于用例的实例，即用例是对同一功能的各种可能场景的抽象和概括

【参与者Actor】是系统范围之外的，与系统进行交互的元素。参与者对应的是一种角色，而不是具体的对象；同一对象可以在系统中作为不同的参与者存在。参与者可以是人、系统、软硬件设备，甚至是时间等能启动系统功能或是系统与之交互的任何元素。

==用例与参与者之间的关系是**关联**==









## 2.7 用例图User Case







## 通信图





# 3用例建模 Use-Case Modeling

> 3.1前言（使用UML画图很容易，建模用来解决我们“画什么”这个困难的问题）
> 3.2需求（需求是什么，如何采集需求）
> 3.3基于用例的需求分析过程
> 3.4用例建模示例

## 3.1&3.2 前言&需求

**需求：系统必须满足的条件或具备的能力**

（我的理解：需求就是甲方对我们构建的系统的要求。）

需求本身难捕获且易变，我们对需求本身也容易存在误区，因此需求也需要开发。

需求收集包括五个关键步骤：

1. 找到可以帮助你理解这个系统的人
2. 倾听这些相关人员的描述，并从他们的角度来理解系统
3. 利用一个容易理解的模型来描述用户希望如何使用这个系统以及为他们提供的什么价值
4. 详细地描述系统和客户以及系统和外部系统之间的交互
5. 重构（refactor）这个详细描述以保证它是可读且易懂的

## 3.3 基于用例的需求分析过程

> 1.获取原始需求（略）
> 2.**开发一个可以理解的需求**：实际上就是一个画用例图的过程
> 2.1识别参与者 -> 2.2识别用例 -> 2.3构建用例图
> 3.详细、完整地描述需求：进行用例阐述，写用例规约（用例文档）
> 4.重构用例模型
> 4.1识别用例间的关系
> 4.2对用例进行组织和分包

### 3.3.2 开发一个可理解的需求

**【参与者】**

参与者Actor：参与者是**在系统之外**，透过**系统边界**与系统进行**有意义交互**的任何事物。参与者可以是人、外系统、外部因素、时间等事物。（**要学会识别参与者**）

参与者的**泛化**：<img src="/Users/letme/Library/Application Support/typora-user-images/截屏2022-04-06 10.40.10.png" alt="截屏2022-04-06 10.40.10" style="zoom: 50%;" />

**【用例】**

用例Use-Case：用例实例是**系统执行**的**一系列动作**，这些动作将生成特定**参与者可观测的结果值**（可以简单理解为：用例就是一个功能，一个函数）

**用例的要点：**

1. 用例是**描述交互**的功能，而**不是系统内在的系统活动**。**不能把系统活动当用例**。例如在登录过程中，不能将**建立数据库连接**，**执行SQL语句**作为用例
2. 一个用例对应一个系统的**具体的功能**
3. 用例是业务语言而非技术语言——用例使用的是用户词汇，而不是技术词汇。如：发票，商品，洗衣机，而不是：记录，字段，COM，C++等
4. 用例的结果值**由系统生成**（与系统有关）。用例是需要系统处理的，系统为我们提供的服务。一个用例不能是与系统无关的事情。

用例**粒度**的确定：如果用例粒度定义过细，则会陷入功能分解。过细的粒度，一般都会导致技术语言的描述，而不再是业务语言（每一个用例成为了一个步骤）

【例子】

| <img src="/Users/letme/Library/Application Support/typora-user-images/截屏2022-04-06 08.37.04.png" alt="截屏2022-04-06 08.37.04" style="zoom:33%;" /> | <img src="/Users/letme/Library/Application Support/typora-user-images/截屏2022-04-06 08.39.53.png" alt="截屏2022-04-06 08.39.53" style="zoom:33%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原用例图                                                     | 修改后的用例图                                               |

错误一：发送邮件和收邮件的用例关系不能在用例图中刻画。用例图中用例的关系只有三种。

错误二：发件人和收件人都是终端的使用者，因此他们既可以发邮件也可以收邮件。

错误三：系统边界之外不能有“系统”作为一个Actor。终端可以定时进行查看是否有新邮件，如果有进行提醒，这是属于系统范围之内的。

因此，修改后的绘制更有效，更完整。

【**用例之间三种关系：泛化，包含，扩展**】

* 包含include：（**函数和子函数的关系**）在箭头发起点是基本用例，箭头指向的是被包含用例（依赖关系的一种）
* 扩展extend：（在某种条件下，可能会执行额外的步骤）箭头发起点是扩展用例，箭头指向是基本用例`注意一下这里的箭头指向和包含关系是相反的`（依赖关系的一种）
* 泛化generalization：



### 3.3.3 详细、完整地描述需求

用例图是骨架，而用例规约则是其内在的肉。用例规约就是全面的介绍一下，包括用例名称、用例标识、涉及的参与者、描述、**用例的规格说明**和其它非功能需求、设计约束、尚存在的问题等。

其中用例的规格说明又包括前置条件 PreConditions、后置条件 PostConditions、正常事件流 Flow of events和备选事件流 Alternate flow。

为了补充，我们可以在用例说明中画一个**活动图**，来帮助我们更好的分析用例。一张完整的活动图是所有用例的集成图。

