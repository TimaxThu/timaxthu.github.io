---
color: #007FC8
---



# 题目1

求最大子数组异或和。

（应该想到的：1.子数组必须是连续的 2. 看到子数组想每个位置结尾的时候答案是啥）

我们可能会先想到求最大累加和。累加和好解决，i位置之前的最大累加和不可能大于i-1位置的那个ans。但是异或和没有这个「累加和单调性」的性质。

## 整体的思路

异或的性质：
假如现在已知0 - i 位的异或和
想求 a - i 的异或和，只需要用 0 - i 的异或和 ^ 0 - (a-1) 的异或和即可得到

因此如果我想知道以 i 结尾的最大异或和（必须包括第 i 位）
我只需要知道

* 0（别忘了这个，表示就是i自己，和谁都不异或）
* 0 - 0 异或和
* 0 - 1 异或和
* ...
* 0 - i-1 异或和

把他们放在一个集合里面，让他们分别和「 0 - i 异或和」异或，最终得到的就是**以 i 结尾的最大异或和**。

然后我们再把「 0 - i 异或和」放到集合里面，再求以 i+1 结尾的最大异或和时，集合中的内容就是 所有计算过程需要的异或和，一一异或就可以。



## 进一步优化（前缀树）

完成上面求解O(N^2)，可以优化的地方就是存储异或和的这个集合。如果用一个傻map，每个字符结尾求解时，都要把map遍历一遍。

可以用**前缀树**，来存储异或和，将遍历过程O(n)变成直接找到最大的异或和的O(常数)操作。

前缀树的**路上**放着0和1信息（int二进制的每一位，从高位到低位）

现在，让「 0 - i 异或和」与前缀树匹配来找最大的异或和，**匹配**过程如下：

因为二叉树从上到下是从int二进制的高位到低位，所以总是先让高位的异或结果变为1，最后结果就是最大值。（贪心的思想）

因此，对于非符号位，假设「 0 - i 异或和」的某一个二进制位是1，就在字典树对应的那个节点，看看有没有0的路，有的话就像0走。

符号位的贪心策略则是尽可能是正数，因此符号位尽可能相同，异或结果为0。

总结一下匹配贪心策略：

最前面的符号位，希望^的结果为0，希望遇到一样的；
后面的非符号位，希望可以让^的结果为1；
在字典树上，如果想要的那个方向可以走，就去那个方向，
如果想去的那个方向没有路，就去另一个方向。



# 题目2

利用题目一的前缀树，这回求「下标为 i 的数」和前面哪个数异或和最大，把 0 - i-1 这写数放到前缀树中，常数时间就可以知道最大的异或和。

然后把「下标为 i 的数」挂到前缀树上，再求 i+1 的最大异或和......








