---
date: 2022-05-26
course: 体系班 第30节 蓄水池算法
detail: - 计数排序
        - 基数排序&代码实现
---







# 基于比较的排序&不基于比较的排序

【基于比较的排序】

冒泡排序，插入排序，选择排序，归并，快，堆，希尔排序等，都属于基于比较的排序。

基于比较的排序算法的最优时间复杂度为：O(NlogN)。 希尔排序O(N^1.3) ~ O(N^2) (O(N^1.3)没有O(NlogN)好)

【不基于比较的排序】

不基于比较的排序，数据范围特殊，例如桶排序。扩展性没有基于比较的排序好，但时间复杂度可以达到 O(N)，比较特殊。





# 计数排序 CountSort

计数排序（CountSort）是**桶排序的一种**，桶是容器，利用容器的思想就属于桶排序。

比如要排序员工的年龄，员工年龄有一个确定的范围，例如就是10到200
因此，我们使用一个单独的数组，记录每个年龄员工的个数。然后按照数组中的数量输出即可。

这个方法的时间复杂度为O(n)

计数排序没有**比较的行为**，但**数据必须有特殊范围**。

按照桶排序的思想，这里，**每个员工的年龄就是一个桶**。





# 基数排序 RadixSort

数据范围限制：非负，可以表达成十进制（这样比较方便基数排序的进行）

过程：高位用0补全，准备10个桶（0-9）从个位开始，利用桶进行排序；排好后，用十位桶排序；一直进行



> 待排序的数字：
> 9 28 35 221 127 89 7
> 高位用0补全：
> 009 028 035 221 127 089 007
> 遍历，用个位进行桶排序：
> 1桶：221     5桶：035    7桶：127 007    8桶：028    9桶：009 089
> 个位桶排序排好后的顺序：
> 221 035 127 007 028 009 089
> 遍历，用十位进行桶排序：
> 0桶：007 009 2桶：221 127 028   3桶：035    8桶：089
> 十位桶排序排好后的顺序：
> 007 009 221 127 028 035 089
> 遍历，用百位进行桶排序：
> 0桶：007 009 028 035 089    1桶：127   2桶：221
> 最终拍好后的排序
> 007 009 028 035 089 127 221



如果想要用负数，可以把整个数组加上最小的负数的绝对值，这样都是非负数了。排序后再减掉。（但是需要注意这样也有隐患，比如可能会出现溢出）。



## 代码实现





```java
//fixme 基数排序代码实现——没有桶，但是实现了出桶入桶的过程
//例如对个位数字遍历的过程中，首先找出个位数字中各个数字出现的次数，放在count数组中，count[0-9]
// 然后将count数组从左到右自增，使得count[i]代表数组中个位小于i的数字个数和
// 随后数组从右向左遍历，例如最右侧的数字015个位为5，count[5]=4代表个位数字小于等于5的有4个，他整体占据排序后数组的0-3位
// 又因为现在是从右向左遍历的，所以015应该放在这4个数字的最右侧，即放在第3位
// 随后将count[5]--，count[5]还有3个

//TODO 为什么修改count数组时只需要对当前的count值修改，不需要对其他部分进行修改呢？
// 这就是优雅的地方。因为每个count值只是表示当前个位为i的情况下，最右侧的值应该放在哪里，和其他数的增加是没有变化的
```
